// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: revenue.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getRevenue = `-- name: GetRevenue :many
select o.payment_id, p.id, p.name, p.type, p.logo, p.created_at, p.updated_at, sum(total_price) as total_amount
from orders o join payments p on p.id = o.payment_id 
where date(o.created_at) = curdate() 
group by payment_id
`

type GetRevenueRow struct {
	PaymentID   int32          `json:"payment_id"`
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Type        string         `json:"type"`
	Logo        sql.NullString `json:"logo"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	TotalAmount float64    `json:"total_amount"`
}

func (q *Queries) GetRevenue(ctx context.Context) ([]GetRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueRow
	for rows.Next() {
		var i GetRevenueRow
		if err := rows.Scan(
			&i.PaymentID,
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Logo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
